{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport createHandler from \"./createHandler\";\nimport { baseGestureHandlerProps } from \"./gestureHandlerCommon\";\nexport var panGestureHandlerProps = ['activeOffsetY', 'activeOffsetX', 'failOffsetY', 'failOffsetX', 'minDist', 'minVelocity', 'minVelocityX', 'minVelocityY', 'minPointers', 'maxPointers', 'avgTouches', 'enableTrackpadTwoFingerGesture'];\nexport var panGestureHandlerCustomNativeProps = ['activeOffsetYStart', 'activeOffsetYEnd', 'activeOffsetXStart', 'activeOffsetXEnd', 'failOffsetYStart', 'failOffsetYEnd', 'failOffsetXStart', 'failOffsetXEnd'];\nexport var PanGestureHandler = createHandler({\n  name: 'PanGestureHandler',\n  allowedProps: [].concat(_toConsumableArray(baseGestureHandlerProps), panGestureHandlerProps),\n  config: {},\n  transformProps: managePanProps,\n  customNativeProps: panGestureHandlerCustomNativeProps\n});\n\nfunction validatePanGestureHandlerProps(props) {\n  if (Array.isArray(props.activeOffsetX) && (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)) {\n    throw new Error(\"First element of activeOffsetX should be negative, a the second one should be positive\");\n  }\n\n  if (Array.isArray(props.activeOffsetY) && (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)) {\n    throw new Error(\"First element of activeOffsetY should be negative, a the second one should be positive\");\n  }\n\n  if (Array.isArray(props.failOffsetX) && (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)) {\n    throw new Error(\"First element of failOffsetX should be negative, a the second one should be positive\");\n  }\n\n  if (Array.isArray(props.failOffsetY) && (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)) {\n    throw new Error(\"First element of failOffsetY should be negative, a the second one should be positive\");\n  }\n\n  if (props.minDist && (props.failOffsetX || props.failOffsetY)) {\n    throw new Error(\"It is not supported to use minDist with failOffsetX or failOffsetY, use activeOffsetX and activeOffsetY instead\");\n  }\n\n  if (props.minDist && (props.activeOffsetX || props.activeOffsetY)) {\n    throw new Error(\"It is not supported to use minDist with activeOffsetX or activeOffsetY\");\n  }\n}\n\nfunction transformPanGestureHandlerProps(props) {\n  var res = _objectSpread({}, props);\n\n  if (props.activeOffsetX !== undefined) {\n    delete res.activeOffsetX;\n\n    if (Array.isArray(props.activeOffsetX)) {\n      res.activeOffsetXStart = props.activeOffsetX[0];\n      res.activeOffsetXEnd = props.activeOffsetX[1];\n    } else if (props.activeOffsetX < 0) {\n      res.activeOffsetXStart = props.activeOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.activeOffsetX;\n    }\n  }\n\n  if (props.activeOffsetY !== undefined) {\n    delete res.activeOffsetY;\n\n    if (Array.isArray(props.activeOffsetY)) {\n      res.activeOffsetYStart = props.activeOffsetY[0];\n      res.activeOffsetYEnd = props.activeOffsetY[1];\n    } else if (props.activeOffsetY < 0) {\n      res.activeOffsetYStart = props.activeOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.activeOffsetY;\n    }\n  }\n\n  if (props.failOffsetX !== undefined) {\n    delete res.failOffsetX;\n\n    if (Array.isArray(props.failOffsetX)) {\n      res.failOffsetXStart = props.failOffsetX[0];\n      res.failOffsetXEnd = props.failOffsetX[1];\n    } else if (props.failOffsetX < 0) {\n      res.failOffsetXStart = props.failOffsetX;\n    } else {\n      res.failOffsetXEnd = props.failOffsetX;\n    }\n  }\n\n  if (props.failOffsetY !== undefined) {\n    delete res.failOffsetY;\n\n    if (Array.isArray(props.failOffsetY)) {\n      res.failOffsetYStart = props.failOffsetY[0];\n      res.failOffsetYEnd = props.failOffsetY[1];\n    } else if (props.failOffsetY < 0) {\n      res.failOffsetYStart = props.failOffsetY;\n    } else {\n      res.failOffsetYEnd = props.failOffsetY;\n    }\n  }\n\n  return res;\n}\n\nexport function managePanProps(props) {\n  if (__DEV__) {\n    validatePanGestureHandlerProps(props);\n  }\n\n  return transformPanGestureHandlerProps(props);\n}","map":{"version":3,"sources":["PanGestureHandler.ts"],"names":["panGestureHandlerProps","panGestureHandlerCustomNativeProps","PanGestureHandler","createHandler","name","allowedProps","config","transformProps","customNativeProps","Array","props","res","validatePanGestureHandlerProps","transformPanGestureHandlerProps"],"mappings":"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","sourcesContent":["import createHandler from './createHandler';\nimport {\n  BaseGestureHandlerProps,\n  baseGestureHandlerProps,\n} from './gestureHandlerCommon';\n\nexport const panGestureHandlerProps = [\n  'activeOffsetY',\n  'activeOffsetX',\n  'failOffsetY',\n  'failOffsetX',\n  'minDist',\n  'minVelocity',\n  'minVelocityX',\n  'minVelocityY',\n  'minPointers',\n  'maxPointers',\n  'avgTouches',\n  'enableTrackpadTwoFingerGesture',\n] as const;\n\nexport const panGestureHandlerCustomNativeProps = [\n  'activeOffsetYStart',\n  'activeOffsetYEnd',\n  'activeOffsetXStart',\n  'activeOffsetXEnd',\n  'failOffsetYStart',\n  'failOffsetYEnd',\n  'failOffsetXStart',\n  'failOffsetXEnd',\n] as const;\n\nexport type PanGestureHandlerEventPayload = {\n  /**\n   * X coordinate of the current position of the pointer (finger or a leading\n   * pointer when there are multiple fingers placed) relative to the view\n   * attached to the handler. Expressed in point units.\n   */\n  x: number;\n\n  /**\n   * Y coordinate of the current position of the pointer (finger or a leading\n   * pointer when there are multiple fingers placed) relative to the view\n   * attached to the handler. Expressed in point units.\n   */\n  y: number;\n\n  /**\n   * X coordinate of the current position of the pointer (finger or a leading\n   * pointer when there are multiple fingers placed) relative to the window.\n   * The value is expressed in point units. It is recommended to use it instead\n   * of `x` in cases when the original view can be transformed as an effect of\n   * the gesture.\n   */\n  absoluteX: number;\n\n  /**\n   * Y coordinate of the current position of the pointer (finger or a leading\n   * pointer when there are multiple fingers placed) relative to the window.\n   * The value is expressed in point units. It is recommended to use it instead\n   * of `y` in cases when the original view can be transformed as an\n   * effect of the gesture.\n   */\n  absoluteY: number;\n\n  /**\n   * Translation of the pan gesture along X axis accumulated over the time of\n   * the gesture. The value is expressed in the point units.\n   */\n  translationX: number;\n\n  /**\n   * Translation of the pan gesture along Y axis accumulated over the time of\n   * the gesture. The value is expressed in the point units.\n   */\n  translationY: number;\n\n  /**\n   * Velocity of the pan gesture along the X axis in the current moment. The\n   * value is expressed in point units per second.\n   */\n  velocityX: number;\n\n  /**\n   * Velocity of the pan gesture along the Y axis in the current moment. The\n   * value is expressed in point units per second.\n   */\n  velocityY: number;\n};\n\ninterface CommonPanProperties {\n  /**\n   * Minimum distance the finger (or multiple finger) need to travel before the\n   * handler activates. Expressed in points.\n   */\n  minDist?: number;\n\n  /**\n   * Android only.\n   */\n  avgTouches?: boolean;\n\n  /**\n   * Enables two-finger gestures on supported devices, for example iPads with\n   * trackpads. If not enabled the gesture will require click + drag, with\n   * enableTrackpadTwoFingerGesture swiping with two fingers will also trigger\n   * the gesture.\n   */\n  enableTrackpadTwoFingerGesture?: boolean;\n\n  /**\n   * A number of fingers that is required to be placed before handler can\n   * activate. Should be a higher or equal to 0 integer.\n   */\n  minPointers?: number;\n\n  /**\n   * When the given number of fingers is placed on the screen and handler hasn't\n   * yet activated it will fail recognizing the gesture. Should be a higher or\n   * equal to 0 integer.\n   */\n  maxPointers?: number;\n\n  minVelocity?: number;\n  minVelocityX?: number;\n  minVelocityY?: number;\n}\n\nexport interface PanGestureConfig extends CommonPanProperties {\n  activeOffsetYStart?: number;\n  activeOffsetYEnd?: number;\n  activeOffsetXStart?: number;\n  activeOffsetXEnd?: number;\n  failOffsetYStart?: number;\n  failOffsetYEnd?: number;\n  failOffsetXStart?: number;\n  failOffsetXEnd?: number;\n}\n\nexport interface PanGestureHandlerProps\n  extends BaseGestureHandlerProps<PanGestureHandlerEventPayload>,\n    CommonPanProperties {\n  /**\n   * Range along X axis (in points) where fingers travels without activation of\n   * handler. Moving outside of this range implies activation of handler. Range\n   * can be given as an array or a single number. If range is set as an array,\n   * first value must be lower or equal to 0, a the second one higher or equal\n   * to 0. If only one number `p` is given a range of `(-inf, p)` will be used\n   * if `p` is higher or equal to 0 and `(-p, inf)` otherwise.\n   */\n  activeOffsetY?: number | number[];\n\n  /**\n   * Range along X axis (in points) where fingers travels without activation of\n   * handler. Moving outside of this range implies activation of handler. Range\n   * can be given as an array or a single number. If range is set as an array,\n   * first value must be lower or equal to 0, a the second one higher or equal\n   * to 0. If only one number `p` is given a range of `(-inf, p)` will be used\n   * if `p` is higher or equal to 0 and `(-p, inf)` otherwise.\n   */\n  activeOffsetX?: number | number[];\n\n  /**\n   * When the finger moves outside this range (in points) along Y axis and\n   * handler hasn't yet activated it will fail recognizing the gesture. Range\n   * can be given as an array or a single number. If range is set as an array,\n   * first value must be lower or equal to 0, a the second one higher or equal\n   * to 0. If only one number `p` is given a range of `(-inf, p)` will be used\n   * if `p` is higher or equal to 0 and `(-p, inf)` otherwise.\n   */\n  failOffsetY?: number | number[];\n\n  /**\n   * When the finger moves outside this range (in points) along X axis and\n   * handler hasn't yet activated it will fail recognizing the gesture. Range\n   * can be given as an array or a single number. If range is set as an array,\n   * first value must be lower or equal to 0, a the second one higher or equal\n   * to 0. If only one number `p` is given a range of `(-inf, p)` will be used\n   * if `p` is higher or equal to 0 and `(-p, inf)` otherwise.\n   */\n  failOffsetX?: number | number[];\n}\n\nexport type PanGestureHandler = typeof PanGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlerCommon.ts file\nexport const PanGestureHandler = createHandler<\n  PanGestureHandlerProps,\n  PanGestureHandlerEventPayload\n>({\n  name: 'PanGestureHandler',\n  allowedProps: [\n    ...baseGestureHandlerProps,\n    ...panGestureHandlerProps,\n  ] as const,\n  config: {},\n  transformProps: managePanProps,\n  customNativeProps: panGestureHandlerCustomNativeProps,\n});\n\nfunction validatePanGestureHandlerProps(props: PanGestureHandlerProps) {\n  if (\n    Array.isArray(props.activeOffsetX) &&\n    (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)\n  ) {\n    throw new Error(\n      `First element of activeOffsetX should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.activeOffsetY) &&\n    (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)\n  ) {\n    throw new Error(\n      `First element of activeOffsetY should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.failOffsetX) &&\n    (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)\n  ) {\n    throw new Error(\n      `First element of failOffsetX should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.failOffsetY) &&\n    (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)\n  ) {\n    throw new Error(\n      `First element of failOffsetY should be negative, a the second one should be positive`\n    );\n  }\n\n  if (props.minDist && (props.failOffsetX || props.failOffsetY)) {\n    throw new Error(\n      `It is not supported to use minDist with failOffsetX or failOffsetY, use activeOffsetX and activeOffsetY instead`\n    );\n  }\n\n  if (props.minDist && (props.activeOffsetX || props.activeOffsetY)) {\n    throw new Error(\n      `It is not supported to use minDist with activeOffsetX or activeOffsetY`\n    );\n  }\n}\n\nfunction transformPanGestureHandlerProps(props: PanGestureHandlerProps) {\n  type InternalPanGHKeys =\n    | 'activeOffsetXStart'\n    | 'activeOffsetXEnd'\n    | 'failOffsetXStart'\n    | 'failOffsetXEnd'\n    | 'activeOffsetYStart'\n    | 'activeOffsetYEnd'\n    | 'failOffsetYStart'\n    | 'failOffsetYEnd';\n  type PanGestureHandlerInternalProps = PanGestureHandlerProps &\n    Partial<Record<InternalPanGHKeys, number>>;\n\n  const res: PanGestureHandlerInternalProps = { ...props };\n\n  if (props.activeOffsetX !== undefined) {\n    delete res.activeOffsetX;\n    if (Array.isArray(props.activeOffsetX)) {\n      res.activeOffsetXStart = props.activeOffsetX[0];\n      res.activeOffsetXEnd = props.activeOffsetX[1];\n    } else if (props.activeOffsetX < 0) {\n      res.activeOffsetXStart = props.activeOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.activeOffsetX;\n    }\n  }\n\n  if (props.activeOffsetY !== undefined) {\n    delete res.activeOffsetY;\n    if (Array.isArray(props.activeOffsetY)) {\n      res.activeOffsetYStart = props.activeOffsetY[0];\n      res.activeOffsetYEnd = props.activeOffsetY[1];\n    } else if (props.activeOffsetY < 0) {\n      res.activeOffsetYStart = props.activeOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.activeOffsetY;\n    }\n  }\n\n  if (props.failOffsetX !== undefined) {\n    delete res.failOffsetX;\n    if (Array.isArray(props.failOffsetX)) {\n      res.failOffsetXStart = props.failOffsetX[0];\n      res.failOffsetXEnd = props.failOffsetX[1];\n    } else if (props.failOffsetX < 0) {\n      res.failOffsetXStart = props.failOffsetX;\n    } else {\n      res.failOffsetXEnd = props.failOffsetX;\n    }\n  }\n\n  if (props.failOffsetY !== undefined) {\n    delete res.failOffsetY;\n    if (Array.isArray(props.failOffsetY)) {\n      res.failOffsetYStart = props.failOffsetY[0];\n      res.failOffsetYEnd = props.failOffsetY[1];\n    } else if (props.failOffsetY < 0) {\n      res.failOffsetYStart = props.failOffsetY;\n    } else {\n      res.failOffsetYEnd = props.failOffsetY;\n    }\n  }\n\n  return res;\n}\n\nexport function managePanProps(props: PanGestureHandlerProps) {\n  if (__DEV__) {\n    validatePanGestureHandlerProps(props);\n  }\n  return transformPanGestureHandlerProps(props);\n}\n"]},"metadata":{},"sourceType":"module"}