{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}var _Reanimated$default$c,_Reanimated$default;import React,{useEffect,useRef}from'react';import{BaseGesture,CALLBACK_TYPE}from\"./gesture\";import{Reanimated}from\"./reanimatedWrapper\";import{registerHandler,unregisterHandler}from\"../handlersRegistry\";import RNGestureHandlerModule from\"../../RNGestureHandlerModule\";import{baseGestureHandlerWithMonitorProps,filterConfig,findNodeHandle}from\"../gestureHandlerCommon\";import{GestureStateManager}from\"./gestureStateManager\";import{flingGestureHandlerProps}from\"../FlingGestureHandler\";import{forceTouchGestureHandlerProps}from\"../ForceTouchGestureHandler\";import{longPressGestureHandlerProps}from\"../LongPressGestureHandler\";import{panGestureHandlerProps,panGestureHandlerCustomNativeProps}from\"../PanGestureHandler\";import{tapGestureHandlerProps}from\"../TapGestureHandler\";import{State}from\"../../State\";import{EventType}from\"../../EventType\";import Platform from\"react-native-web/dist/exports/Platform\";import{onGestureHandlerEvent as _onGestureHandlerEvent}from\"./eventReceiver\";var ALLOWED_PROPS=[].concat(_toConsumableArray(baseGestureHandlerWithMonitorProps),_toConsumableArray(tapGestureHandlerProps),_toConsumableArray(panGestureHandlerProps),_toConsumableArray(panGestureHandlerCustomNativeProps),_toConsumableArray(longPressGestureHandlerProps),_toConsumableArray(forceTouchGestureHandlerProps),_toConsumableArray(flingGestureHandlerProps));function convertToHandlerTag(ref){if(typeof ref==='number'){return ref;}else if(ref instanceof BaseGesture){return ref.handlerTag;}else{var _ref$current$handlerT,_ref$current;return(_ref$current$handlerT=(_ref$current=ref.current)===null||_ref$current===void 0?void 0:_ref$current.handlerTag)!==null&&_ref$current$handlerT!==void 0?_ref$current$handlerT:-1;}}function extractValidHandlerTags(interactionGroup){var _interactionGroup$map,_interactionGroup$map2;return(_interactionGroup$map=interactionGroup===null||interactionGroup===void 0?void 0:(_interactionGroup$map2=interactionGroup.map(convertToHandlerTag))===null||_interactionGroup$map2===void 0?void 0:_interactionGroup$map2.filter(function(tag){return tag>0;}))!==null&&_interactionGroup$map!==void 0?_interactionGroup$map:[];}function dropHandlers(preparedGesture){for(var _iterator=_createForOfIteratorHelperLoose(preparedGesture.config),_step;!(_step=_iterator()).done;){var handler=_step.value;RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);unregisterHandler(handler.handlerTag);}}function attachHandlers(_ref){var preparedGesture=_ref.preparedGesture,gestureConfig=_ref.gestureConfig,gesture=_ref.gesture,viewTag=_ref.viewTag,useAnimated=_ref.useAnimated,webEventHandlersRef=_ref.webEventHandlersRef;if(!preparedGesture.firstExecution){gestureConfig===null||gestureConfig===void 0?void 0:gestureConfig.initialize();}else{preparedGesture.firstExecution=false;}setImmediate(function(){gestureConfig===null||gestureConfig===void 0?void 0:gestureConfig.prepare();});var _loop=function _loop(handler){RNGestureHandlerModule.createGestureHandler(handler.handlerName,handler.handlerTag,filterConfig(handler.config,ALLOWED_PROPS));registerHandler(handler.handlerTag,handler);setImmediate(function(){var requireToFail=[];if(handler.config.requireToFail){requireToFail=extractValidHandlerTags(handler.config.requireToFail);}var simultaneousWith=[];if(handler.config.simultaneousWith){simultaneousWith=extractValidHandlerTags(handler.config.simultaneousWith);}RNGestureHandlerModule.updateGestureHandler(handler.handlerTag,filterConfig(handler.config,ALLOWED_PROPS,{simultaneousHandlers:simultaneousWith,waitFor:requireToFail}));});};for(var _iterator2=_createForOfIteratorHelperLoose(gesture),_step2;!(_step2=_iterator2()).done;){var handler=_step2.value;_loop(handler);}preparedGesture.config=gesture;for(var _iterator3=_createForOfIteratorHelperLoose(preparedGesture.config),_step3;!(_step3=_iterator3()).done;){var _gesture=_step3.value;if(Platform.OS==='web'){RNGestureHandlerModule.attachGestureHandler(_gesture.handlerTag,viewTag,!useAnimated,webEventHandlersRef);}else{RNGestureHandlerModule.attachGestureHandler(_gesture.handlerTag,viewTag,!useAnimated);}}if(preparedGesture.animatedHandlers){preparedGesture.animatedHandlers.value=gesture.map(function(g){return g.handlers;});}}function updateHandlers(preparedGesture,gestureConfig,gesture){gestureConfig===null||gestureConfig===void 0?void 0:gestureConfig.prepare();for(var i=0;i<gesture.length;i++){var handler=preparedGesture.config[i];if(gesture[i].handlerTag!==handler.handlerTag){gesture[i].handlerTag=handler.handlerTag;gesture[i].handlers.handlerTag=handler.handlerTag;}}setImmediate(function(){for(var _i=0;_i<gesture.length;_i++){var _handler=preparedGesture.config[_i];_handler.config=gesture[_i].config;_handler.handlers=gesture[_i].handlers;var requireToFail=extractValidHandlerTags(_handler.config.requireToFail);var simultaneousWith=extractValidHandlerTags(_handler.config.simultaneousWith);RNGestureHandlerModule.updateGestureHandler(_handler.handlerTag,filterConfig(_handler.config,ALLOWED_PROPS,{simultaneousHandlers:simultaneousWith,waitFor:requireToFail}));registerHandler(_handler.handlerTag,_handler);}if(preparedGesture.animatedHandlers){preparedGesture.animatedHandlers.value=preparedGesture.config.map(function(g){return g.handlers;});}});}function needsToReattach(preparedGesture,gesture){if(gesture.length!==preparedGesture.config.length){return true;}for(var i=0;i<gesture.length;i++){if(gesture[i].handlerName!==preparedGesture.config[i].handlerName){return true;}}return false;}function useAnimatedGesture(preparedGesture,needsRebuild){if(!Reanimated){return;}var isStateChangeEvent=function(){var _f=function _f(event){return event.oldState!=null;};_f._closure={};_f.asString=\"function isStateChangeEvent(event){return event.oldState!=null;}\";_f.__workletHash=13883357260557;_f.__location=\"/Users/essam/Documents/GitHub/Quizzery-React-Native/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector.js (165:2)\";return _f;}();var isTouchEvent=function(){var _f=function _f(event){return event.eventType!=null;};_f._closure={};_f.asString=\"function isTouchEvent(event){return event.eventType!=null;}\";_f.__workletHash=15872269086045;_f.__location=\"/Users/essam/Documents/GitHub/Quizzery-React-Native/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector.js (171:2)\";return _f;}();var getHandler=function(){var _f=function _f(type,gesture){switch(type){case CALLBACK_TYPE.BEGAN:return gesture.onBegin;case CALLBACK_TYPE.START:return gesture.onStart;case CALLBACK_TYPE.UPDATE:return gesture.onUpdate;case CALLBACK_TYPE.CHANGE:return gesture.onChange;case CALLBACK_TYPE.END:return gesture.onEnd;case CALLBACK_TYPE.FINALIZE:return gesture.onFinalize;case CALLBACK_TYPE.TOUCHES_DOWN:return gesture.onTouchesDown;case CALLBACK_TYPE.TOUCHES_MOVE:return gesture.onTouchesMove;case CALLBACK_TYPE.TOUCHES_UP:return gesture.onTouchesUp;case CALLBACK_TYPE.TOUCHES_CANCELLED:return gesture.onTouchesCancelled;}};_f._closure={CALLBACK_TYPE:{BEGAN:CALLBACK_TYPE.BEGAN,START:CALLBACK_TYPE.START,UPDATE:CALLBACK_TYPE.UPDATE,CHANGE:CALLBACK_TYPE.CHANGE,END:CALLBACK_TYPE.END,FINALIZE:CALLBACK_TYPE.FINALIZE,TOUCHES_DOWN:CALLBACK_TYPE.TOUCHES_DOWN,TOUCHES_MOVE:CALLBACK_TYPE.TOUCHES_MOVE,TOUCHES_UP:CALLBACK_TYPE.TOUCHES_UP,TOUCHES_CANCELLED:CALLBACK_TYPE.TOUCHES_CANCELLED}};_f.asString=\"function getHandler(type,gesture){const{CALLBACK_TYPE}=jsThis._closure;{switch(type){case CALLBACK_TYPE.BEGAN:return gesture.onBegin;case CALLBACK_TYPE.START:return gesture.onStart;case CALLBACK_TYPE.UPDATE:return gesture.onUpdate;case CALLBACK_TYPE.CHANGE:return gesture.onChange;case CALLBACK_TYPE.END:return gesture.onEnd;case CALLBACK_TYPE.FINALIZE:return gesture.onFinalize;case CALLBACK_TYPE.TOUCHES_DOWN:return gesture.onTouchesDown;case CALLBACK_TYPE.TOUCHES_MOVE:return gesture.onTouchesMove;case CALLBACK_TYPE.TOUCHES_UP:return gesture.onTouchesUp;case CALLBACK_TYPE.TOUCHES_CANCELLED:return gesture.onTouchesCancelled;}}}\";_f.__workletHash=13033906201160;_f.__location=\"/Users/essam/Documents/GitHub/Quizzery-React-Native/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector.js (177:2)\";return _f;}();var touchEventTypeToCallbackType=function(){var _f=function _f(eventType){switch(eventType){case EventType.TOUCHES_DOWN:return CALLBACK_TYPE.TOUCHES_DOWN;case EventType.TOUCHES_MOVE:return CALLBACK_TYPE.TOUCHES_MOVE;case EventType.TOUCHES_UP:return CALLBACK_TYPE.TOUCHES_UP;case EventType.TOUCHES_CANCELLED:return CALLBACK_TYPE.TOUCHES_CANCELLED;}return CALLBACK_TYPE.UNDEFINED;};_f._closure={EventType:{TOUCHES_DOWN:EventType.TOUCHES_DOWN,TOUCHES_MOVE:EventType.TOUCHES_MOVE,TOUCHES_UP:EventType.TOUCHES_UP,TOUCHES_CANCELLED:EventType.TOUCHES_CANCELLED},CALLBACK_TYPE:{TOUCHES_DOWN:CALLBACK_TYPE.TOUCHES_DOWN,TOUCHES_MOVE:CALLBACK_TYPE.TOUCHES_MOVE,TOUCHES_UP:CALLBACK_TYPE.TOUCHES_UP,TOUCHES_CANCELLED:CALLBACK_TYPE.TOUCHES_CANCELLED,UNDEFINED:CALLBACK_TYPE.UNDEFINED}};_f.asString=\"function touchEventTypeToCallbackType(eventType){const{EventType,CALLBACK_TYPE}=jsThis._closure;{switch(eventType){case EventType.TOUCHES_DOWN:return CALLBACK_TYPE.TOUCHES_DOWN;case EventType.TOUCHES_MOVE:return CALLBACK_TYPE.TOUCHES_MOVE;case EventType.TOUCHES_UP:return CALLBACK_TYPE.TOUCHES_UP;case EventType.TOUCHES_CANCELLED:return CALLBACK_TYPE.TOUCHES_CANCELLED;}return CALLBACK_TYPE.UNDEFINED;}}\";_f.__workletHash=4665487911277;_f.__location=\"/Users/essam/Documents/GitHub/Quizzery-React-Native/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector.js (213:2)\";return _f;}();var runWorklet=function(){var _f=function _f(type,gesture,event){var handler=getHandler(type,gesture);if(gesture.isWorklet[type]){for(var _len=arguments.length,args=new Array(_len>3?_len-3:0),_key=3;_key<_len;_key++){args[_key-3]=arguments[_key];}handler===null||handler===void 0?void 0:handler.apply(void 0,[event].concat(args));}else if(handler){console.warn('Animated gesture callback must be a worklet');}};_f._closure={getHandler:getHandler};_f.asString=\"function runWorklet(type,gesture,event,...args){const{getHandler}=jsThis._closure;{const handler=getHandler(type,gesture);if(gesture.isWorklet[type]){handler===null||handler===void 0?void 0:handler(event,...args);}else if(handler){console.warn('Animated gesture callback must be a worklet');}}}\";_f.__workletHash=3175729087786;_f.__location=\"/Users/essam/Documents/GitHub/Quizzery-React-Native/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector.js (233:2)\";return _f;}();var sharedHandlersCallbacks=Reanimated.useSharedValue(null);var lastUpdateEvent=Reanimated.useSharedValue([]);var stateControllers=[];var callback=function(){var _f=function _f(event){var currentCallback=sharedHandlersCallbacks.value;if(!currentCallback){return;}for(var i=0;i<currentCallback.length;i++){var gesture=currentCallback[i];if(event.handlerTag===gesture.handlerTag){if(isStateChangeEvent(event)){if(event.oldState===State.UNDETERMINED&&event.state===State.BEGAN){runWorklet(CALLBACK_TYPE.BEGAN,gesture,event);}else if((event.oldState===State.BEGAN||event.oldState===State.UNDETERMINED)&&event.state===State.ACTIVE){runWorklet(CALLBACK_TYPE.START,gesture,event);lastUpdateEvent.value[gesture.handlerTag]=undefined;}else if(event.oldState!==event.state&&event.state===State.END){if(event.oldState===State.ACTIVE){runWorklet(CALLBACK_TYPE.END,gesture,event,true);}runWorklet(CALLBACK_TYPE.FINALIZE,gesture,event,true);}else if((event.state===State.FAILED||event.state===State.CANCELLED)&&event.state!==event.oldState){if(event.oldState===State.ACTIVE){runWorklet(CALLBACK_TYPE.END,gesture,event,false);}runWorklet(CALLBACK_TYPE.FINALIZE,gesture,event,false);}}else if(isTouchEvent(event)){if(!stateControllers[i]){stateControllers[i]=GestureStateManager.create(event.handlerTag);}if(event.eventType!==EventType.UNDETERMINED){runWorklet(touchEventTypeToCallbackType(event.eventType),gesture,event,stateControllers[i]);}}else{runWorklet(CALLBACK_TYPE.UPDATE,gesture,event);if(gesture.onChange&&gesture.changeEventCalculator){var _gesture$changeEventC;runWorklet(CALLBACK_TYPE.CHANGE,gesture,(_gesture$changeEventC=gesture.changeEventCalculator)===null||_gesture$changeEventC===void 0?void 0:_gesture$changeEventC.call(gesture,event,lastUpdateEvent.value[gesture.handlerTag]));lastUpdateEvent.value[gesture.handlerTag]=event;}}}}};_f._closure={sharedHandlersCallbacks:sharedHandlersCallbacks,isStateChangeEvent:isStateChangeEvent,State:{UNDETERMINED:State.UNDETERMINED,BEGAN:State.BEGAN,ACTIVE:State.ACTIVE,END:State.END,FAILED:State.FAILED,CANCELLED:State.CANCELLED},runWorklet:runWorklet,CALLBACK_TYPE:{BEGAN:CALLBACK_TYPE.BEGAN,START:CALLBACK_TYPE.START,END:CALLBACK_TYPE.END,FINALIZE:CALLBACK_TYPE.FINALIZE,UPDATE:CALLBACK_TYPE.UPDATE,CHANGE:CALLBACK_TYPE.CHANGE},lastUpdateEvent:lastUpdateEvent,isTouchEvent:isTouchEvent,stateControllers:stateControllers,GestureStateManager:{create:GestureStateManager.create},EventType:{UNDETERMINED:EventType.UNDETERMINED},touchEventTypeToCallbackType:touchEventTypeToCallbackType};_f.asString=\"function _f(event){const{sharedHandlersCallbacks,isStateChangeEvent,State,runWorklet,CALLBACK_TYPE,lastUpdateEvent,isTouchEvent,stateControllers,GestureStateManager,EventType,touchEventTypeToCallbackType}=jsThis._closure;{const currentCallback=sharedHandlersCallbacks.value;if(!currentCallback){return;}for(let i=0;i<currentCallback.length;i++){const gesture=currentCallback[i];if(event.handlerTag===gesture.handlerTag){if(isStateChangeEvent(event)){if(event.oldState===State.UNDETERMINED&&event.state===State.BEGAN){runWorklet(CALLBACK_TYPE.BEGAN,gesture,event);}else if((event.oldState===State.BEGAN||event.oldState===State.UNDETERMINED)&&event.state===State.ACTIVE){runWorklet(CALLBACK_TYPE.START,gesture,event);lastUpdateEvent.value[gesture.handlerTag]=undefined;}else if(event.oldState!==event.state&&event.state===State.END){if(event.oldState===State.ACTIVE){runWorklet(CALLBACK_TYPE.END,gesture,event,true);}runWorklet(CALLBACK_TYPE.FINALIZE,gesture,event,true);}else if((event.state===State.FAILED||event.state===State.CANCELLED)&&event.state!==event.oldState){if(event.oldState===State.ACTIVE){runWorklet(CALLBACK_TYPE.END,gesture,event,false);}runWorklet(CALLBACK_TYPE.FINALIZE,gesture,event,false);}}else if(isTouchEvent(event)){if(!stateControllers[i]){stateControllers[i]=GestureStateManager.create(event.handlerTag);}if(event.eventType!==EventType.UNDETERMINED){runWorklet(touchEventTypeToCallbackType(event.eventType),gesture,event,stateControllers[i]);}}else{runWorklet(CALLBACK_TYPE.UPDATE,gesture,event);if(gesture.onChange&&gesture.changeEventCalculator){var _gesture$changeEventC;runWorklet(CALLBACK_TYPE.CHANGE,gesture,(_gesture$changeEventC=gesture.changeEventCalculator)===null||_gesture$changeEventC===void 0?void 0:_gesture$changeEventC.call(gesture,event,lastUpdateEvent.value[gesture.handlerTag]));lastUpdateEvent.value[gesture.handlerTag]=event;}}}}}}\";_f.__workletHash=8983705865779;_f.__location=\"/Users/essam/Documents/GitHub/Quizzery-React-Native/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector.js (256:19)\";return _f;}();var event=Reanimated.useEvent(callback,['onGestureHandlerStateChange','onGestureHandlerEvent'],needsRebuild);preparedGesture.animatedEventHandler=event;preparedGesture.animatedHandlers=sharedHandlersCallbacks;}export var GestureDetector=function GestureDetector(props){var _gestureConfig$toGest,_gestureConfig$toGest2;var gestureConfig=props.gesture;var gesture=(_gestureConfig$toGest=gestureConfig===null||gestureConfig===void 0?void 0:(_gestureConfig$toGest2=gestureConfig.toGestureArray)===null||_gestureConfig$toGest2===void 0?void 0:_gestureConfig$toGest2.call(gestureConfig))!==null&&_gestureConfig$toGest!==void 0?_gestureConfig$toGest:[];var useAnimated=gesture.find(function(gesture){return gesture.handlers.isWorklet.reduce(function(prev,current){return prev||current;});})!=null;var viewRef=useRef(null);var firstRenderRef=useRef(true);var webEventHandlersRef=useRef({onGestureHandlerEvent:function onGestureHandlerEvent(e){_onGestureHandlerEvent(e.nativeEvent);}});var preparedGesture=React.useRef({config:gesture,animatedEventHandler:null,animatedHandlers:null,firstExecution:true,useAnimated:useAnimated}).current;if(useAnimated!==preparedGesture.useAnimated){throw new Error('You cannot change whether you are using gesture or animatedGesture while the app is running');}var needsToRebuildReanimatedEvent=preparedGesture.firstExecution||needsToReattach(preparedGesture,gesture);if(preparedGesture.firstExecution){var _gestureConfig$initia;gestureConfig===null||gestureConfig===void 0?void 0:(_gestureConfig$initia=gestureConfig.initialize)===null||_gestureConfig$initia===void 0?void 0:_gestureConfig$initia.call(gestureConfig);}if(useAnimated){useAnimatedGesture(preparedGesture,needsToRebuildReanimatedEvent);}useEffect(function(){firstRenderRef.current=true;var viewTag=findNodeHandle(viewRef.current);attachHandlers({preparedGesture:preparedGesture,gestureConfig:gestureConfig,gesture:gesture,viewTag:viewTag,useAnimated:useAnimated,webEventHandlersRef:webEventHandlersRef});return function(){dropHandlers(preparedGesture);};},[]);useEffect(function(){if(!firstRenderRef.current){var viewTag=findNodeHandle(viewRef.current);if(needsToReattach(preparedGesture,gesture)){dropHandlers(preparedGesture);attachHandlers({preparedGesture:preparedGesture,gestureConfig:gestureConfig,gesture:gesture,viewTag:viewTag,useAnimated:useAnimated,webEventHandlersRef:webEventHandlersRef});}else{updateHandlers(preparedGesture,gestureConfig,gesture);}}else{firstRenderRef.current=false;}},[props]);if(useAnimated){return React.createElement(AnimatedWrap,{ref:viewRef,onGestureHandlerEvent:preparedGesture.animatedEventHandler},props.children);}else{return React.createElement(Wrap,{ref:viewRef},props.children);}};var Wrap=function(_React$Component){_inherits(Wrap,_React$Component);var _super=_createSuper(Wrap);function Wrap(){_classCallCheck(this,Wrap);return _super.apply(this,arguments);}_createClass(Wrap,[{key:\"render\",value:function render(){var child=React.Children.only(this.props.children);return React.cloneElement(child,{collapsable:false},child.props.children);}}]);return Wrap;}(React.Component);var AnimatedWrap=(_Reanimated$default$c=Reanimated===null||Reanimated===void 0?void 0:(_Reanimated$default=Reanimated.default)===null||_Reanimated$default===void 0?void 0:_Reanimated$default.createAnimatedComponent(Wrap))!==null&&_Reanimated$default$c!==void 0?_Reanimated$default$c:Wrap;","map":{"version":3,"sources":["GestureDetector.tsx"],"names":["useEffect","BaseGesture","CALLBACK_TYPE","Reanimated","RNGestureHandlerModule","baseGestureHandlerWithMonitorProps","flingGestureHandlerProps","forceTouchGestureHandlerProps","panGestureHandlerProps","tapGestureHandlerProps","onGestureHandlerEvent","ALLOWED_PROPS","ref","handlerTag","interactionGroup","tag","dropHandlers","preparedGesture","handler","unregisterHandler","webEventHandlersRef","gestureConfig","setImmediate","filterConfig","registerHandler","requireToFail","extractValidHandlerTags","simultaneousWith","simultaneousHandlers","waitFor","Platform","gesture","g","i","event","EventType","getHandler","console","sharedHandlersCallbacks","lastUpdateEvent","stateControllers","callback","currentCallback","isStateChangeEvent","State","runWorklet","isTouchEvent","GestureStateManager","touchEventTypeToCallbackType","GestureDetector","props","useAnimated","prev","viewRef","useRef","firstRenderRef","e","config","animatedEventHandler","animatedHandlers","firstExecution","needsToRebuildReanimatedEvent","needsToReattach","useAnimatedGesture","viewTag","findNodeHandle","attachHandlers","updateHandlers","React","render","child","collapsable","AnimatedWrap"],"mappings":"uqEAAA,MAAA,MAAA,EAAgBA,SAAhB,CAAA,MAAA,KAAA,OAAA,CACA,OAGEC,WAHF,CAKEC,aALF,iBAOA,OAASC,UAAT,2BACA,OAAA,eAAA,CAAA,iBAAA,2BACA,MAAOC,uBAAP,oCACA,OACEC,kCADF,CAAA,YAAA,CAAA,cAAA,+BASA,OAAA,mBAAA,6BAIA,OAASC,wBAAT,8BACA,OAASC,6BAAT,mCACA,OAAA,4BAAA,kCACA,OACEC,sBADF,CAAA,kCAAA,4BAIA,OAASC,sBAAT,4BACA,OAAA,KAAA,mBACA,OAAA,SAAA,uB,6DAIA,OAASC,qBAAT,GAASA,uBAAT,uBAEA,GAAMC,cAAa,8BAAG,kCAAH,qBAEdF,sBAFc,qBAAG,sBAAH,qBAAG,kCAAH,qBAAG,4BAAH,qBAAG,6BAAH,qBAAnB,wBAAmB,EAAnB,CAoBA,QAAA,oBAAA,CAAA,GAAA,CAAsD,CACpD,GAAI,MAAA,IAAA,GAAe,QAAnB,CAA6B,CAC3B,MAAA,IAAA,CADF,CAAA,IAEO,IAAIG,GAAG,WAAP,YAAA,CAAgC,CACrC,MAAOA,IAAG,CAACC,UAAX,CADK,CAAA,IAEA,CAAA,GAAA,sBAAA,CAAA,YAAA,CAGL,MAAA,CAAA,qBAAA,CAAA,CAAA,YAAA,CAAOD,GAAG,CAAV,OAAA,IAAA,IAAA,EAAA,YAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,CAAOA,YAAAA,CAAP,UAAA,IAAA,IAAA,EAAA,qBAAA,GAAA,IAAA,EAAA,CAAA,qBAAA,CAAkC,CAAlC,CAAA,CACD,CACF,CAED,QAAA,wBAAA,CAAA,gBAAA,CAA6E,CAAA,GAAA,sBAAA,CAAA,sBAAA,CAC3E,MAAA,CAAA,qBAAA,CACEE,gBADF,GAAA,IACEA,EAAAA,gBADF,GAAA,IAAA,EACEA,CADF,IAAA,EACEA,CADF,CAAA,sBAAA,CACEA,gBAAgB,CAAhBA,GAAAA,CADF,mBACEA,CADF,IAAA,IAAA,EAAA,sBAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,CACEA,sBAAAA,CAAAA,MAAAA,CAAoDC,SAAAA,GAAD,QAASA,IAAG,CADjE,CACqD,EAAnDD,CADF,IAAA,IAAA,EAAA,qBAAA,GAAA,IAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,CAGD,CAED,QAASE,aAAT,CAAsBC,eAAtB,CAA+D,CAC7D,kDAAsBA,eAAe,CAArC,MAAA,mCAA8C,IAA9C,QAA8C,aAC5Cb,sBAAsB,CAAtBA,kBAAAA,CAA0Cc,OAAO,CAAjDd,UAAAA,EAEAe,iBAAiB,CAACD,OAAO,CAAzBC,UAAiB,CAAjBA,CACD,CACF,CAeD,QAAA,eAAA,MAOyB,IAPD,gBAOC,MAPD,eAOC,CAPD,aAOC,MAPD,aAOC,CAPD,OAOC,MAPD,OAOC,CAPD,OAOC,MAPD,OAOC,CAPD,WAOC,MAPD,WAOC,CADvBC,mBACuB,MADvBA,mBACuB,CACvB,GAAI,CAACH,eAAe,CAApB,cAAA,CAAqC,CACnCI,aAAa,GAAbA,IAAAA,EAAAA,aAAa,GAAA,IAAbA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,aAAa,CAAbA,UAAAA,EAAAA,CADF,CAAA,IAEO,CACLJ,eAAe,CAAfA,cAAAA,CAAAA,KAAAA,CAJqB,CASvBK,YAAY,CAAC,UAAM,CACjBD,aAAa,GAAbA,IAAAA,EAAAA,aAAa,GAAA,IAAbA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,aAAa,CAAbA,OAAAA,EAAAA,CADFC,CAAY,CAAZA,CATuB,yBAavB,OAbuB,EAcrBlB,sBAAsB,CAAtBA,oBAAAA,CACEc,OAAO,CADTd,WAAAA,CAEEc,OAAO,CAFTd,UAAAA,CAGEmB,YAAY,CAACL,OAAO,CAAR,MAAA,CAHdd,aAGc,CAHdA,EAMAoB,eAAe,CAACN,OAAO,CAAR,UAAA,CAPc,OAOd,CAAfM,CAIAF,YAAY,CAAC,UAAM,CACjB,GAAIG,cAAuB,CAA3B,EAAA,CACA,GAAIP,OAAO,CAAPA,MAAAA,CAAJ,aAAA,CAAkC,CAChCO,aAAa,CAAGC,uBAAuB,CAACR,OAAO,CAAPA,MAAAA,CAAxCO,aAAuC,CAAvCA,CACD,CAED,GAAIE,iBAA0B,CAA9B,EAAA,CACA,GAAIT,OAAO,CAAPA,MAAAA,CAAJ,gBAAA,CAAqC,CACnCS,gBAAgB,CAAGD,uBAAuB,CACxCR,OAAO,CAAPA,MAAAA,CADFS,gBAA0C,CAA1CA,CAGD,CAEDvB,sBAAsB,CAAtBA,oBAAAA,CACEc,OAAO,CADTd,UAAAA,CAEEmB,YAAY,CAACL,OAAO,CAAR,MAAA,CAAA,aAAA,CAAgC,CAC1CU,oBAAoB,CADsB,gBAAA,CAE1CC,OAAO,CAAEJ,aAFiC,CAAhC,CAFdrB,EAbFkB,CAAY,CAAZA,CAxBqB,EAavB,mDAAA,OAAA,sCAA+B,IAA/B,QAA+B,oBAA/B,OAA+B,EAgC9B,CACDL,eAAe,CAAfA,MAAAA,CAAAA,OAAAA,CAEA,mDAAsBA,eAAe,CAArC,MAAA,sCAA8C,IAA9C,SAA8C,cAC5C,GAAIa,QAAQ,CAARA,EAAAA,GAAJ,KAAA,CAA2B,CACxB1B,sBAAsB,CAAvB,oBAACA,CACC2B,QAAO,CADT,UAAC3B,CAAD,OAACA,CAGC,CAHF,WAACA,CAAD,mBAACA,EADH,CAAA,IAOO,CACLA,sBAAsB,CAAtBA,oBAAAA,CACE2B,QAAO,CADT3B,UAAAA,CAAAA,OAAAA,CAGE,CAHFA,WAAAA,EAKD,CACF,CAED,GAAIa,eAAe,CAAnB,gBAAA,CAAsC,CACpCA,eAAe,CAAfA,gBAAAA,CAAAA,KAAAA,CAA0Cc,OAAO,CAAPA,GAAAA,CACvCC,SAAAA,CAAD,QAAOA,EAAC,CADVf,QACE,EADwCc,CAA1Cd,CAGD,CACF,CAED,QAAA,eAAA,CAAA,eAAA,CAAA,aAAA,CAAA,OAAA,CAIE,CACAI,aAAa,GAAbA,IAAAA,EAAAA,aAAa,GAAA,IAAbA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,aAAa,CAAbA,OAAAA,EAAAA,CAEA,IAAK,GAAIY,EAAC,CAAV,CAAA,CAAgBA,CAAC,CAAGF,OAAO,CAA3B,MAAA,CAAoCE,CAApC,EAAA,CAAyC,CACvC,GAAMf,QAAO,CAAGD,eAAe,CAAfA,MAAAA,CADuB,CACvBA,CAAhB,CAIA,GAAIc,OAAO,CAAPA,CAAO,CAAPA,CAAAA,UAAAA,GAA0Bb,OAAO,CAArC,UAAA,CAAkD,CAChDa,OAAO,CAAPA,CAAO,CAAPA,CAAAA,UAAAA,CAAwBb,OAAO,CAA/Ba,UAAAA,CACAA,OAAO,CAAPA,CAAO,CAAPA,CAAAA,QAAAA,CAAAA,UAAAA,CAAiCb,OAAO,CAAxCa,UAAAA,CACD,CAXH,CAiBAT,YAAY,CAAC,UAAM,CACjB,IAAK,GAAIW,GAAC,CAAV,CAAA,CAAgBA,EAAC,CAAGF,OAAO,CAA3B,MAAA,CAAoCE,EAApC,EAAA,CAAyC,CACvC,GAAMf,SAAO,CAAGD,eAAe,CAAfA,MAAAA,CAAhB,EAAgBA,CAAhB,CAEAC,QAAO,CAAPA,MAAAA,CAAiBa,OAAO,CAAPA,EAAO,CAAPA,CAAjBb,MAAAA,CACAA,QAAO,CAAPA,QAAAA,CAAmBa,OAAO,CAAPA,EAAO,CAAPA,CAAnBb,QAAAA,CAEA,GAAMO,cAAa,CAAGC,uBAAuB,CAC3CR,QAAO,CAAPA,MAAAA,CADF,aAA6C,CAA7C,CAIA,GAAMS,iBAAgB,CAAGD,uBAAuB,CAC9CR,QAAO,CAAPA,MAAAA,CADF,gBAAgD,CAAhD,CAIAd,sBAAsB,CAAtBA,oBAAAA,CACEc,QAAO,CADTd,UAAAA,CAEEmB,YAAY,CAACL,QAAO,CAAR,MAAA,CAAA,aAAA,CAAgC,CAC1CU,oBAAoB,CADsB,gBAAA,CAE1CC,OAAO,CAAEJ,aAFiC,CAAhC,CAFdrB,EAQAoB,eAAe,CAACN,QAAO,CAAR,UAAA,CAAfM,QAAe,CAAfA,CACD,CAED,GAAIP,eAAe,CAAnB,gBAAA,CAAsC,CACpCA,eAAe,CAAfA,gBAAAA,CAAAA,KAAAA,CAA0CA,eAAe,CAAfA,MAAAA,CAAAA,GAAAA,CACvCe,SAAAA,CAAD,QAAOA,EAAC,CADVf,QACE,EADwCA,CAA1CA,CAGD,CA9BHK,CAAY,CAAZA,CAgCD,CAED,QAAA,gBAAA,CAAA,eAAA,CAAA,OAAA,CAGE,CACA,GAAIS,OAAO,CAAPA,MAAAA,GAAmBd,eAAe,CAAfA,MAAAA,CAAvB,MAAA,CAAsD,CACpD,MAAA,KAAA,CACD,CACD,IAAK,GAAIgB,EAAC,CAAV,CAAA,CAAgBA,CAAC,CAAGF,OAAO,CAA3B,MAAA,CAAoCE,CAApC,EAAA,CAAyC,CACvC,GAAIF,OAAO,CAAPA,CAAO,CAAPA,CAAAA,WAAAA,GAA2Bd,eAAe,CAAfA,MAAAA,CAAAA,CAAAA,EAA/B,WAAA,CAAsE,CACpE,MAAA,KAAA,CACD,CACF,CAED,MAAA,MAAA,CACD,CAED,QAAA,mBAAA,CAAA,eAAA,CAAA,YAAA,CAGE,CACA,GAAI,CAAJ,UAAA,CAAiB,CACf,OACD,CAHD,GAKA,mBALA,+BAKA,KALA,CAOoC,CAGlC,MAAOiB,MAAK,CAALA,QAAAA,EAAP,IAAA,CACD,CAXD,sTAaA,aAbA,+BAaA,KAbA,CAe8B,CAE5B,MAAOA,MAAK,CAALA,SAAAA,EAAP,IAAA,CACD,CAlBD,iTAoBA,WApBA,+BAoBA,IApBA,CAoBA,OApBA,CAuBE,CAEA,OAAA,IAAA,EACE,IAAKhC,cAAa,CAAlB,KAAA,CACE,MAAO6B,QAAO,CAAd,OAAA,CACF,IAAK7B,cAAa,CAAlB,KAAA,CACE,MAAO6B,QAAO,CAAd,OAAA,CACF,IAAK7B,cAAa,CAAlB,MAAA,CACE,MAAO6B,QAAO,CAAd,QAAA,CACF,IAAK7B,cAAa,CAAlB,MAAA,CACE,MAAO6B,QAAO,CAAd,QAAA,CACF,IAAK7B,cAAa,CAAlB,GAAA,CACE,MAAO6B,QAAO,CAAd,KAAA,CACF,IAAK7B,cAAa,CAAlB,QAAA,CACE,MAAO6B,QAAO,CAAd,UAAA,CACF,IAAK7B,cAAa,CAAlB,YAAA,CACE,MAAO6B,QAAO,CAAd,aAAA,CACF,IAAK7B,cAAa,CAAlB,YAAA,CACE,MAAO6B,QAAO,CAAd,aAAA,CACF,IAAK7B,cAAa,CAAlB,UAAA,CACE,MAAO6B,QAAO,CAAd,WAAA,CACF,IAAK7B,cAAa,CAAlB,iBAAA,CACE,MAAO6B,QAAO,CAAd,kBAAA,CApBJ,CAsBD,CA/CD,mCAvPA9B,aAEAC,CALF,KA0PE,OAjPKE,aAAAA,CAAP,KAiPE,QAnOOE,aAAAA,CAAT,MAmOE,QA/NAE,aAAAA,CADF,MAgOE,KA1NF,aAAA,CAAA,GA0NE,UApNIG,aAAgB,CACpB,QAmNA,cA/LI,aAAe,CAAnB,YA+LA,cA5LE,aAAWE,CAAX,YA4LF,Y,wBAAA,mBAxLE,aAAA,CAAA,iBAwLF,i2BAiDA,6BAjDA,+BAiDA,SAjDA,CAiD2E,CAEzE,OAAA,SAAA,EACE,IAAKsB,UAAS,CAAd,YAAA,CACE,MAAOjC,cAAa,CAApB,YAAA,CACF,IAAKiC,UAAS,CAAd,YAAA,CACE,MAAOjC,cAAa,CAApB,YAAA,CACF,IAAKiC,UAAS,CAAd,UAAA,CACE,MAAOjC,cAAa,CAApB,UAAA,CACF,IAAKiC,UAAS,CAAd,iBAAA,CACE,MAAOjC,cAAa,CAApB,iBAAA,CARJ,CAUA,MAAOA,cAAa,CAApB,SAAA,CACD,CA9DD,sCAvPAD,SAAAA,CAHF,YA0PE,cAjPKG,SAAAA,CAAAA,YAiPL,YAnOOE,SAAAA,CAAAA,UAmOP,mBA/NAE,SAAAA,CAAAA,iBA+NA,8BAnPF,aAAA,CAAA,YAmPE,cA/OAH,aAAAA,CADF,YAgPE,YAlOOE,aAAAA,CAAT,UAkOE,mBA5NOE,aAAAA,CAAT,iBA4NE,WAxNF,aAAA,CAAA,SAwNE,2nBAgEA,WAhEA,+BAgEA,IAhEA,CAgEA,OAhEA,CAgEA,KAhEA,CAqEE,CAEA,GAAMS,QAAO,CAAGkB,UAAU,CAAA,IAAA,CAA1B,OAA0B,CAA1B,CACA,GAAIL,OAAO,CAAPA,SAAAA,CAAJ,IAAIA,CAAJ,CAA6B,+BAR/B,IAQ+B,qDAR/B,IAQ+B,0BAG3Bb,OAAO,GAAPA,IAAAA,EAAAA,OAAO,GAAA,IAAPA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,OAAO,MAAPA,SAAO,KAAPA,SAAAA,IAAAA,EAAAA,CAHF,CAAA,IAIO,IAAA,OAAA,CAAa,CAClBmB,OAAO,CAAPA,IAAAA,CAAAA,6CAAAA,EACD,CA9EH,CAAA,yBA3PF,UA2PE,0gBAoFA,GAAMC,wBAAuB,CAAGnC,UAAU,CAAVA,cAAAA,CApFhC,IAoFgCA,CAAhC,CAKA,GAAMoC,gBAAe,CAAGpC,UAAU,CAAVA,cAAAA,CAzFxB,EAyFwBA,CAAxB,CAKA,GAAMqC,iBAA2C,CAAjD,EAAA,CAEA,GAAMC,SAAQ,+BAAG,KAAH,CAET,CAGH,GAAMC,gBAAe,CAAGJ,uBAAuB,CAA/C,KAAA,CACA,GAAI,CAAJ,eAAA,CAAsB,CACpB,OACD,CAED,IAAK,GAAIL,EAAC,CAAV,CAAA,CAAgBA,CAAC,CAAGS,eAAe,CAAnC,MAAA,CAA4CT,CAA5C,EAAA,CAAiD,CAC/C,GAAMF,QAAO,CAAGW,eAAe,CAA/B,CAA+B,CAA/B,CAEA,GAAIR,KAAK,CAALA,UAAAA,GAAqBH,OAAO,CAAhC,UAAA,CAA6C,CAC3C,GAAIY,kBAAkB,CAAtB,KAAsB,CAAtB,CAA+B,CAC7B,GACET,KAAK,CAALA,QAAAA,GAAmBU,KAAK,CAAxBV,YAAAA,EACAA,KAAK,CAALA,KAAAA,GAAgBU,KAAK,CAFvB,KAAA,CAGE,CACAC,UAAU,CAAC3C,aAAa,CAAd,KAAA,CAAA,OAAA,CAAV2C,KAAU,CAAVA,CAJF,CAAA,IAKO,IACL,CAACX,KAAK,CAALA,QAAAA,GAAmBU,KAAK,CAAxBV,KAAAA,EACCA,KAAK,CAALA,QAAAA,GAAmBU,KAAK,CAD1B,YAAA,GAEAV,KAAK,CAALA,KAAAA,GAAgBU,KAAK,CAHhB,MAAA,CAIL,CACAC,UAAU,CAAC3C,aAAa,CAAd,KAAA,CAAA,OAAA,CAAV2C,KAAU,CAAVA,CACAN,eAAe,CAAfA,KAAAA,CAAsBR,OAAO,CAA7BQ,UAAAA,EAAAA,SAAAA,CANK,CAAA,IAOA,IACLL,KAAK,CAALA,QAAAA,GAAmBA,KAAK,CAAxBA,KAAAA,EACAA,KAAK,CAALA,KAAAA,GAAgBU,KAAK,CAFhB,GAAA,CAGL,CACA,GAAIV,KAAK,CAALA,QAAAA,GAAmBU,KAAK,CAA5B,MAAA,CAAqC,CACnCC,UAAU,CAAC3C,aAAa,CAAd,GAAA,CAAA,OAAA,CAAA,KAAA,CAAV2C,IAAU,CAAVA,CACD,CACDA,UAAU,CAAC3C,aAAa,CAAd,QAAA,CAAA,OAAA,CAAA,KAAA,CAAV2C,IAAU,CAAVA,CAPK,CAAA,IAQA,IACL,CAACX,KAAK,CAALA,KAAAA,GAAgBU,KAAK,CAArBV,MAAAA,EAAgCA,KAAK,CAALA,KAAAA,GAAgBU,KAAK,CAAtD,SAAA,GACAV,KAAK,CAALA,KAAAA,GAAgBA,KAAK,CAFhB,QAAA,CAGL,CACA,GAAIA,KAAK,CAALA,QAAAA,GAAmBU,KAAK,CAA5B,MAAA,CAAqC,CACnCC,UAAU,CAAC3C,aAAa,CAAd,GAAA,CAAA,OAAA,CAAA,KAAA,CAAV2C,KAAU,CAAVA,CACD,CACDA,UAAU,CAAC3C,aAAa,CAAd,QAAA,CAAA,OAAA,CAAA,KAAA,CAAV2C,KAAU,CAAVA,CACD,CA7BH,CAAA,IA8BO,IAAIC,YAAY,CAAhB,KAAgB,CAAhB,CAAyB,CAC9B,GAAI,CAACN,gBAAgB,CAArB,CAAqB,CAArB,CAA0B,CACxBA,gBAAgB,CAAhBA,CAAgB,CAAhBA,CAAsBO,mBAAmB,CAAnBA,MAAAA,CAA2Bb,KAAK,CAAtDM,UAAsBO,CAAtBP,CACD,CAED,GAAIN,KAAK,CAALA,SAAAA,GAAoBC,SAAS,CAAjC,YAAA,CAAgD,CAC9CU,UAAU,CACRG,4BAA4B,CAACd,KAAK,CAD1B,SACoB,CADpB,CAAA,OAAA,CAAA,KAAA,CAIRM,gBAAgB,CAJlBK,CAIkB,CAJR,CAAVA,CAMD,CAZI,CAAA,IAaA,CACLA,UAAU,CAAC3C,aAAa,CAAd,MAAA,CAAA,OAAA,CAAV2C,KAAU,CAAVA,CAEA,GAAId,OAAO,CAAPA,QAAAA,EAAoBA,OAAO,CAA/B,qBAAA,CAAuD,CAAA,GAAA,sBAAA,CACrDc,UAAU,CACR3C,aAAa,CADL,MAAA,CAAA,OAAA,CAAA,CAAA,qBAAA,CAGR6B,OAAO,CAHC,qBAAA,IAAA,IAAA,EAAA,qBAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,CAGRA,qBAAAA,CAAAA,IAAAA,CAAAA,OAAAA,CAAO,KAAPA,CAEEQ,eAAe,CAAfA,KAAAA,CAAsBR,OAAO,CALjCc,UAKIN,CAFFR,CAHQ,CAAVc,CASAN,eAAe,CAAfA,KAAAA,CAAsBR,OAAO,CAA7BQ,UAAAA,EAAAA,KAAAA,CACD,CACF,CACF,CACF,CA1KH,CAgGc,sCA3VhB,uBA2VgB,oBA/Td/B,kBA+Tc,qBA1ThB,KAAA,CAAA,YA0TgB,OA1ThB,KAAA,CAAA,KA0TgB,QA3RP,KAAA,CAAA,MA2RO,KAlTXC,KAAAA,CAFiB,GAoTN,QA5RZ,KAAA,CAAA,MA4RY,WA5RZ,KAAA,CAAA,SA4RY,aAxQf,UAwQe,sBA3ThB,aAAsB,CAAtB,KA2TgB,OAxThB,aAAyB,CAAzB,KAwTgB,KA3RP,aAAA,CAAA,GA2RO,UAzRZ,aAAA,CAAA,QAyRY,QA9QhB,aAAsBQ,CAAtB,MA8QgB,QAxQf,aAAA,CAAA,MAwQe,kB,eAAA,cAvRb,YAuRa,kBAnRd,gBAmRc,6B,0BAAA,0B,sBAAA,+BAnRd,4BAmRc,2jEAAd,CA8EA,GAAMiB,MAAK,CAAG/B,UAAU,CAAVA,QAAAA,CAAAA,QAAAA,CAEZ,CAAA,6BAAA,CAFYA,uBAEZ,CAFYA,CAAd,YAAcA,CAAd,CAMAc,eAAe,CAAfA,oBAAAA,CAAAA,KAAAA,CACAA,eAAe,CAAfA,gBAAAA,CAAAA,uBAAAA,CACD,CAKD,MAAO,IAAMgC,gBAA8D,CACzEC,QADWD,gBACXC,CAAAA,KAD4E,CAEzE,CAAA,GAAA,sBAAA,CAAA,sBAAA,CACH,GAAM7B,cAAa,CAAG6B,KAAK,CAA3B,OAAA,CACA,GAAMnB,QAAO,CAAA,CAAA,qBAAA,CAAGV,aAAH,GAAA,IAAGA,EAAAA,aAAH,GAAA,IAAA,EAAGA,CAAH,IAAA,EAAGA,CAAH,CAAA,sBAAA,CAAGA,aAAa,CAAhB,cAAA,IAAA,IAAA,EAAA,sBAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,CAAGA,sBAAAA,CAAAA,IAAAA,CAAH,aAAGA,CAAH,IAAA,IAAA,EAAA,qBAAA,GAAA,IAAA,EAAA,CAAA,qBAAA,CAAb,EAAA,CACA,GAAM8B,YAAW,CACfpB,OAAO,CAAPA,IAAAA,CAAcA,SAAAA,OAAD,QACXA,QAAO,CAAPA,QAAAA,CAAAA,SAAAA,CAAAA,MAAAA,CAAkC,SAAA,IAAA,CAAA,OAAA,QAAmBqB,KAAI,EAD3DrB,OACoC,EAAlCA,CADW,EAAbA,GADF,IAAA,CAIA,GAAMsB,QAAO,CAAGC,MAAM,CAAtB,IAAsB,CAAtB,CACA,GAAMC,eAAc,CAAGD,MAAM,CAA7B,IAA6B,CAA7B,CACA,GAAMlC,oBAAmB,CAAGkC,MAAM,CAAkB,CAClD5C,qBAAqB,CAAG8C,+BAAAA,CAAD,CAAyC,CAC9D9C,sBAAqB,CAAC8C,CAAC,CAAvB9C,WAAqB,CAArBA,CACD,CAHiD,CAAlB,CAAlC,CAMA,GAAMO,gBAAe,CAAG,KAAK,CAAL,MAAA,CAAqC,CAC3DwC,MAAM,CADqD,OAAA,CAE3DC,oBAAoB,CAFuC,IAAA,CAG3DC,gBAAgB,CAH2C,IAAA,CAI3DC,cAAc,CAJ6C,IAAA,CAK3DT,WAAW,CAAEA,WAL8C,CAArC,EAAxB,OAAA,CAQA,GAAIA,WAAW,GAAKlC,eAAe,CAAnC,WAAA,CAAiD,CAC/C,KAAM,IAAA,MAAA,CAAN,6FAAM,CAAN,CAxBC,CA+BH,GAAM4C,8BAA6B,CACjC5C,eAAe,CAAfA,cAAAA,EAAkC6C,eAAe,CAAA,eAAA,CADnD,OACmD,CADnD,CAGA,GAAI7C,eAAe,CAAnB,cAAA,CAAoC,CAAA,GAAA,sBAAA,CAClCI,aAAa,GAAbA,IAAAA,EAAAA,aAAa,GAAA,IAAbA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,qBAAAA,CAAAA,aAAa,CAAbA,UAAAA,IAAAA,IAAAA,EAAAA,qBAAAA,GAAAA,IAAAA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,qBAAAA,CAAAA,IAAAA,CAAAA,aAAAA,CAAAA,CACD,CAED,GAAA,WAAA,CAAiB,CAIf0C,kBAAkB,CAAA,eAAA,CAAlBA,6BAAkB,CAAlBA,CACD,CAED/D,SAAS,CAAC,UAAM,CACduD,cAAc,CAAdA,OAAAA,CAAAA,IAAAA,CACA,GAAMS,QAAO,CAAGC,cAAc,CAACZ,OAAO,CAAtC,OAA8B,CAA9B,CACAa,cAAc,CAAC,CACbjD,eADa,CACbA,eADa,CAEbI,aAFa,CAEbA,aAFa,CAGbU,OAHa,CAGbA,OAHa,CAIbiC,OAJa,CAIbA,OAJa,CAKbb,WALa,CAKbA,WALa,CAMb/B,mBAAAA,CAAAA,mBANa,CAAD,CAAd8C,CASA,MAAO,WAAM,CACXlD,YAAY,CAAZA,eAAY,CAAZA,CADF,CAAA,CAZO,CAAA,CAAThB,EAAS,CAATA,CAiBAA,SAAS,CAAC,UAAM,CACd,GAAI,CAACuD,cAAc,CAAnB,OAAA,CAA6B,CAC3B,GAAMS,QAAO,CAAGC,cAAc,CAACZ,OAAO,CAAtC,OAA8B,CAA9B,CAEA,GAAIS,eAAe,CAAA,eAAA,CAAnB,OAAmB,CAAnB,CAA+C,CAC7C9C,YAAY,CAAZA,eAAY,CAAZA,CACAkD,cAAc,CAAC,CACbjD,eADa,CACbA,eADa,CAEbI,aAFa,CAEbA,aAFa,CAGbU,OAHa,CAGbA,OAHa,CAIbiC,OAJa,CAIbA,OAJa,CAKbb,WALa,CAKbA,WALa,CAMb/B,mBAAAA,CAAAA,mBANa,CAAD,CAAd8C,CAFF,CAAA,IAUO,CACLC,cAAc,CAAA,eAAA,CAAA,aAAA,CAAdA,OAAc,CAAdA,CACD,CAfH,CAAA,IAgBO,CACLZ,cAAc,CAAdA,OAAAA,CAAAA,KAAAA,CACD,CAnBM,CAAA,CAoBN,CApBHvD,KAoBG,CApBM,CAATA,CAsBA,GAAA,WAAA,CAAiB,CACf,MACE,MAAA,CAAA,aAAA,CAAA,YAAA,CAAA,CACE,GAAG,CADL,OAAA,CAEE,qBAAqB,CAAEiB,eAAe,CAACyC,oBAFzC,CAAA,CAGGR,KAAK,CAJV,QACE,CADF,CADF,CAAA,IAQO,CACL,MAAO,MAAA,CAAA,aAAA,CAAA,IAAA,CAAA,CAAM,GAAG,CAAEG,OAAX,CAAA,CAAqBH,KAAK,CAAjC,QAAO,CAAP,CACD,CAhGI,CAAA,C,GAmGP,K,kNACEmB,iBAAS,CAMP,GAAMC,MAAU,CAAGF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,CAAoB,KAAA,KAAA,CAAvC,QAAmBA,CAAnB,CAEA,MAAO,MAAK,CAAL,YAAA,CAAA,KAAA,CAEL,CAAEG,WAAW,CAAE,KAAf,CAFK,CAILD,KAAK,CAALA,KAAAA,CAJF,QAAO,CAAP,CAMD,C,kBAfgBF,KAAK,CAAxB,S,EAkBA,GAAMI,aAAY,CAAA,CAAA,qBAAA,CAAGrE,UAAH,GAAA,IAAGA,EAAAA,UAAH,GAAA,IAAA,EAAGA,CAAH,IAAA,EAAGA,CAAH,CAAA,mBAAA,CAAGA,UAAU,CAAb,OAAA,IAAA,IAAA,EAAA,mBAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,CAAGA,mBAAAA,CAAAA,uBAAAA,CAAH,IAAGA,CAAH,IAAA,IAAA,EAAA,qBAAA,GAAA,IAAA,EAAA,CAAA,qBAAA,CAAlB,IAAA","sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport {\n  GestureType,\n  HandlerCallbacks,\n  BaseGesture,\n  GestureRef,\n  CALLBACK_TYPE,\n} from './gesture';\nimport { Reanimated, SharedValue } from './reanimatedWrapper';\nimport { registerHandler, unregisterHandler } from '../handlersRegistry';\nimport RNGestureHandlerModule from '../../RNGestureHandlerModule';\nimport {\n  baseGestureHandlerWithMonitorProps,\n  filterConfig,\n  findNodeHandle,\n  GestureTouchEvent,\n  GestureUpdateEvent,\n  GestureStateChangeEvent,\n  HandlerStateChangeEvent,\n} from '../gestureHandlerCommon';\nimport {\n  GestureStateManager,\n  GestureStateManagerType,\n} from './gestureStateManager';\nimport { flingGestureHandlerProps } from '../FlingGestureHandler';\nimport { forceTouchGestureHandlerProps } from '../ForceTouchGestureHandler';\nimport { longPressGestureHandlerProps } from '../LongPressGestureHandler';\nimport {\n  panGestureHandlerProps,\n  panGestureHandlerCustomNativeProps,\n} from '../PanGestureHandler';\nimport { tapGestureHandlerProps } from '../TapGestureHandler';\nimport { State } from '../../State';\nimport { EventType } from '../../EventType';\nimport { ComposedGesture } from './gestureComposition';\nimport { Platform } from 'react-native';\nimport type RNGestureHandlerModuleWeb from '../../RNGestureHandlerModule.web';\nimport { onGestureHandlerEvent } from './eventReceiver';\n\nconst ALLOWED_PROPS = [\n  ...baseGestureHandlerWithMonitorProps,\n  ...tapGestureHandlerProps,\n  ...panGestureHandlerProps,\n  ...panGestureHandlerCustomNativeProps,\n  ...longPressGestureHandlerProps,\n  ...forceTouchGestureHandlerProps,\n  ...flingGestureHandlerProps,\n];\n\nexport type GestureConfigReference = {\n  config: GestureType[];\n  animatedEventHandler: unknown;\n  animatedHandlers: SharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  > | null;\n  firstExecution: boolean;\n  useAnimated: boolean;\n};\n\nfunction convertToHandlerTag(ref: GestureRef): number {\n  if (typeof ref === 'number') {\n    return ref;\n  } else if (ref instanceof BaseGesture) {\n    return ref.handlerTag;\n  } else {\n    // @ts-ignore in this case it should be a ref either to gesture object or\n    // a gesture handler component, in both cases handlerTag property exists\n    return ref.current?.handlerTag ?? -1;\n  }\n}\n\nfunction extractValidHandlerTags(interactionGroup: GestureRef[] | undefined) {\n  return (\n    interactionGroup?.map(convertToHandlerTag)?.filter((tag) => tag > 0) ?? []\n  );\n}\n\nfunction dropHandlers(preparedGesture: GestureConfigReference) {\n  for (const handler of preparedGesture.config) {\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\n\n    unregisterHandler(handler.handlerTag);\n  }\n}\n\ninterface WebEventHandler {\n  onGestureHandlerEvent: (event: HandlerStateChangeEvent<unknown>) => void;\n}\n\ninterface AttachHandlersConfig {\n  preparedGesture: GestureConfigReference;\n  gestureConfig: ComposedGesture | GestureType | undefined;\n  gesture: GestureType[];\n  viewTag: number;\n  useAnimated: boolean;\n  webEventHandlersRef: React.RefObject<WebEventHandler>;\n}\n\nfunction attachHandlers({\n  preparedGesture,\n  gestureConfig,\n  gesture,\n  viewTag,\n  useAnimated,\n  webEventHandlersRef,\n}: AttachHandlersConfig) {\n  if (!preparedGesture.firstExecution) {\n    gestureConfig?.initialize();\n  } else {\n    preparedGesture.firstExecution = false;\n  }\n\n  // use setImmediate to extract handlerTags, because all refs should be initialized\n  // when it's ran\n  setImmediate(() => {\n    gestureConfig?.prepare();\n  });\n\n  for (const handler of gesture) {\n    RNGestureHandlerModule.createGestureHandler(\n      handler.handlerName,\n      handler.handlerTag,\n      filterConfig(handler.config, ALLOWED_PROPS)\n    );\n\n    registerHandler(handler.handlerTag, handler);\n\n    // use setImmediate to extract handlerTags, because all refs should be initialized\n    // when it's ran\n    setImmediate(() => {\n      let requireToFail: number[] = [];\n      if (handler.config.requireToFail) {\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\n      }\n\n      let simultaneousWith: number[] = [];\n      if (handler.config.simultaneousWith) {\n        simultaneousWith = extractValidHandlerTags(\n          handler.config.simultaneousWith\n        );\n      }\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(handler.config, ALLOWED_PROPS, {\n          simultaneousHandlers: simultaneousWith,\n          waitFor: requireToFail,\n        })\n      );\n    });\n  }\n  preparedGesture.config = gesture;\n\n  for (const gesture of preparedGesture.config) {\n    if (Platform.OS === 'web') {\n      (RNGestureHandlerModule.attachGestureHandler as typeof RNGestureHandlerModuleWeb.attachGestureHandler)(\n        gesture.handlerTag,\n        viewTag,\n        !useAnimated, // send direct events when using animatedGesture, device events otherwise\n        webEventHandlersRef\n      );\n    } else {\n      RNGestureHandlerModule.attachGestureHandler(\n        gesture.handlerTag,\n        viewTag,\n        !useAnimated // send direct events when using animatedGesture, device events otherwise\n      );\n    }\n  }\n\n  if (preparedGesture.animatedHandlers) {\n    preparedGesture.animatedHandlers.value = (gesture.map(\n      (g) => g.handlers\n    ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\n  }\n}\n\nfunction updateHandlers(\n  preparedGesture: GestureConfigReference,\n  gestureConfig: ComposedGesture | GestureType | undefined,\n  gesture: GestureType[]\n) {\n  gestureConfig?.prepare();\n\n  for (let i = 0; i < gesture.length; i++) {\n    const handler = preparedGesture.config[i];\n\n    // only update handlerTag when it's actually different, it may be the same\n    // if gesture config object is wrapped with useMemo\n    if (gesture[i].handlerTag !== handler.handlerTag) {\n      gesture[i].handlerTag = handler.handlerTag;\n      gesture[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  // use setImmediate to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  setImmediate(() => {\n    for (let i = 0; i < gesture.length; i++) {\n      const handler = preparedGesture.config[i];\n\n      handler.config = gesture[i].config;\n      handler.handlers = gesture[i].handlers;\n\n      const requireToFail = extractValidHandlerTags(\n        handler.config.requireToFail\n      );\n\n      const simultaneousWith = extractValidHandlerTags(\n        handler.config.simultaneousWith\n      );\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(handler.config, ALLOWED_PROPS, {\n          simultaneousHandlers: simultaneousWith,\n          waitFor: requireToFail,\n        })\n      );\n\n      registerHandler(handler.handlerTag, handler);\n    }\n\n    if (preparedGesture.animatedHandlers) {\n      preparedGesture.animatedHandlers.value = (preparedGesture.config.map(\n        (g) => g.handlers\n      ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\n    }\n  });\n}\n\nfunction needsToReattach(\n  preparedGesture: GestureConfigReference,\n  gesture: GestureType[]\n) {\n  if (gesture.length !== preparedGesture.config.length) {\n    return true;\n  }\n  for (let i = 0; i < gesture.length; i++) {\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction useAnimatedGesture(\n  preparedGesture: GestureConfigReference,\n  needsRebuild: boolean\n) {\n  if (!Reanimated) {\n    return;\n  }\n\n  function isStateChangeEvent(\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n  ): event is GestureStateChangeEvent {\n    'worklet';\n    // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\n    return event.oldState != null;\n  }\n\n  function isTouchEvent(\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n  ): event is GestureTouchEvent {\n    'worklet';\n    return event.eventType != null;\n  }\n\n  function getHandler(\n    type: CALLBACK_TYPE,\n    gesture: HandlerCallbacks<Record<string, unknown>>\n  ) {\n    'worklet';\n    switch (type) {\n      case CALLBACK_TYPE.BEGAN:\n        return gesture.onBegin;\n      case CALLBACK_TYPE.START:\n        return gesture.onStart;\n      case CALLBACK_TYPE.UPDATE:\n        return gesture.onUpdate;\n      case CALLBACK_TYPE.CHANGE:\n        return gesture.onChange;\n      case CALLBACK_TYPE.END:\n        return gesture.onEnd;\n      case CALLBACK_TYPE.FINALIZE:\n        return gesture.onFinalize;\n      case CALLBACK_TYPE.TOUCHES_DOWN:\n        return gesture.onTouchesDown;\n      case CALLBACK_TYPE.TOUCHES_MOVE:\n        return gesture.onTouchesMove;\n      case CALLBACK_TYPE.TOUCHES_UP:\n        return gesture.onTouchesUp;\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\n        return gesture.onTouchesCancelled;\n    }\n  }\n\n  function touchEventTypeToCallbackType(eventType: EventType): CALLBACK_TYPE {\n    'worklet';\n    switch (eventType) {\n      case EventType.TOUCHES_DOWN:\n        return CALLBACK_TYPE.TOUCHES_DOWN;\n      case EventType.TOUCHES_MOVE:\n        return CALLBACK_TYPE.TOUCHES_MOVE;\n      case EventType.TOUCHES_UP:\n        return CALLBACK_TYPE.TOUCHES_UP;\n      case EventType.TOUCHES_CANCELLED:\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\n    }\n    return CALLBACK_TYPE.UNDEFINED;\n  }\n\n  function runWorklet(\n    type: CALLBACK_TYPE,\n    gesture: HandlerCallbacks<Record<string, unknown>>,\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\n    ...args: any[]\n  ) {\n    'worklet';\n    const handler = getHandler(type, gesture);\n    if (gesture.isWorklet[type]) {\n      // @ts-ignore Logic below makes sure the correct event is send to the\n      // correct handler.\n      handler?.(event, ...args);\n    } else if (handler) {\n      console.warn('Animated gesture callback must be a worklet');\n    }\n  }\n\n  // Hooks are called conditionally, but the condition is whether the\n  // react-native-reanimated is installed, which shouldn't change while running\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  >(null);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const lastUpdateEvent = Reanimated.useSharedValue<\n    (GestureUpdateEvent | undefined)[]\n  >([]);\n\n  // not every gesture needs a state controller, init them lazily\n  const stateControllers: GestureStateManagerType[] = [];\n\n  const callback = (\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\n  ) => {\n    'worklet';\n\n    const currentCallback = sharedHandlersCallbacks.value;\n    if (!currentCallback) {\n      return;\n    }\n\n    for (let i = 0; i < currentCallback.length; i++) {\n      const gesture = currentCallback[i];\n\n      if (event.handlerTag === gesture.handlerTag) {\n        if (isStateChangeEvent(event)) {\n          if (\n            event.oldState === State.UNDETERMINED &&\n            event.state === State.BEGAN\n          ) {\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\n          } else if (\n            (event.oldState === State.BEGAN ||\n              event.oldState === State.UNDETERMINED) &&\n            event.state === State.ACTIVE\n          ) {\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\n          } else if (\n            event.oldState !== event.state &&\n            event.state === State.END\n          ) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\n          } else if (\n            (event.state === State.FAILED || event.state === State.CANCELLED) &&\n            event.state !== event.oldState\n          ) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\n          }\n        } else if (isTouchEvent(event)) {\n          if (!stateControllers[i]) {\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\n          }\n\n          if (event.eventType !== EventType.UNDETERMINED) {\n            runWorklet(\n              touchEventTypeToCallbackType(event.eventType),\n              gesture,\n              event,\n              stateControllers[i]\n            );\n          }\n        } else {\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\n\n          if (gesture.onChange && gesture.changeEventCalculator) {\n            runWorklet(\n              CALLBACK_TYPE.CHANGE,\n              gesture,\n              gesture.changeEventCalculator?.(\n                event,\n                lastUpdateEvent.value[gesture.handlerTag]\n              )\n            );\n\n            lastUpdateEvent.value[gesture.handlerTag] = event;\n          }\n        }\n      }\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const event = Reanimated.useEvent(\n    callback,\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\n    needsRebuild\n  );\n\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n\ninterface GestureDetectorProps {\n  gesture?: ComposedGesture | GestureType;\n}\nexport const GestureDetector: React.FunctionComponent<GestureDetectorProps> = (\n  props\n) => {\n  const gestureConfig = props.gesture;\n  const gesture = gestureConfig?.toGestureArray?.() ?? [];\n  const useAnimated =\n    gesture.find((gesture) =>\n      gesture.handlers.isWorklet.reduce((prev, current) => prev || current)\n    ) != null;\n  const viewRef = useRef(null);\n  const firstRenderRef = useRef(true);\n  const webEventHandlersRef = useRef<WebEventHandler>({\n    onGestureHandlerEvent: (e: HandlerStateChangeEvent<unknown>) => {\n      onGestureHandlerEvent(e.nativeEvent);\n    },\n  });\n\n  const preparedGesture = React.useRef<GestureConfigReference>({\n    config: gesture,\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    firstExecution: true,\n    useAnimated: useAnimated,\n  }).current;\n\n  if (useAnimated !== preparedGesture.useAnimated) {\n    throw new Error(\n      'You cannot change whether you are using gesture or animatedGesture while the app is running'\n    );\n  }\n\n  // Reanimated event should be rebuilt only when gestures are reattached, otherwise\n  // config update will be enough as all necessary items are stored in shared values anyway\n  const needsToRebuildReanimatedEvent =\n    preparedGesture.firstExecution || needsToReattach(preparedGesture, gesture);\n\n  if (preparedGesture.firstExecution) {\n    gestureConfig?.initialize?.();\n  }\n\n  if (useAnimated) {\n    // Whether animatedGesture or gesture is used shouldn't change\n    // during while an app is running\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\n  }\n\n  useEffect(() => {\n    firstRenderRef.current = true;\n    const viewTag = findNodeHandle(viewRef.current) as number;\n    attachHandlers({\n      preparedGesture,\n      gestureConfig,\n      gesture,\n      viewTag,\n      useAnimated,\n      webEventHandlersRef,\n    });\n\n    return () => {\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!firstRenderRef.current) {\n      const viewTag = findNodeHandle(viewRef.current) as number;\n\n      if (needsToReattach(preparedGesture, gesture)) {\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture,\n          gestureConfig,\n          gesture,\n          viewTag,\n          useAnimated,\n          webEventHandlersRef,\n        });\n      } else {\n        updateHandlers(preparedGesture, gestureConfig, gesture);\n      }\n    } else {\n      firstRenderRef.current = false;\n    }\n  }, [props]);\n\n  if (useAnimated) {\n    return (\n      <AnimatedWrap\n        ref={viewRef}\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\n        {props.children}\n      </AnimatedWrap>\n    );\n  } else {\n    return <Wrap ref={viewRef}>{props.children}</Wrap>;\n  }\n};\n\nclass Wrap extends React.Component<{ onGestureHandlerEvent?: unknown }> {\n  render() {\n    // I don't think that fighting with types over such a simple function is worth it\n    // The only thing it does is add 'collapsable: false' to the child component\n    // to make sure it is in the native view hierarchy so the detector can find\n    // correct viewTag to attach to.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const child: any = React.Children.only(this.props.children);\n\n    return React.cloneElement(\n      child,\n      { collapsable: false },\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      child.props.children\n    );\n  }\n}\n\nconst AnimatedWrap = Reanimated?.default?.createAnimatedComponent(Wrap) ?? Wrap;\n"]},"metadata":{},"sourceType":"module"}